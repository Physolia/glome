---
authors: Markus Rudy (@burgerdev)
state: discussion
---

# Objective

Make the GLOME Login Protocol unambiguous.


# Background

See also [google/glome#62](https://github.com/google/glome/issues/62).

*   The ambiguous interpretation of `prefix7` may lead to a change of server authorization behaviour that cannot be controlled by the client (e.g. a new key is added to the server whose index conflicts with a public key prefix of an existing one).
*   It's currently legal to have colon (`:`) and slash (`/`) characters in all message fields, which may cause ambiguity in parsing and, ultimately, lead to authorization of unintended messages.
*   The protocol gives advice to "maximize the human readability of the URL", which conflicts with an unambiguous presentation of said characters in percent-encoded form.


# Requirements

*   There must be a well-defined interpretation of the GLOME Login handshake that does not depend on the state of the server.
*   There must be a well-defined, bijective conversion from the message embedded in a GLOME Login URL to the message being authorized.
*   Subject to the preceding requirements, the URL layout should be optimized for human readability (e.g. don't encode unreserved characters, go/rfc/3986#section-2.3) and brevity.
    -   Assuming humans will have to read the message to be authorized much more often than parse the involved keys.


# Design ideas

*   Make the URL generation and interpretation unambiguous.
*   Include detailed instructions for server and client into the protocol.
*   Publish the result as GLOME Login v2.


## URL Format

```
<url-prefix>/v2/<server-pub-trunc>/<client-pub>/<message>/
```

## Handshake

The handshake is simplified to consist of a (truncated) public key of the server and the full public key of the client, given in separate URL segments. The length of the server key should be chosen so that the likelihood of generating conflicting keys is low (see Appendix).

Both public keys are converted to URI segments using URL-safe base64 encoding.


## Message

Define a normalized encoding of the authorization context and compute the tag over that encoding.

New restrictions:

*   hostid-type and hostid must not contain the `:` character.
*   hostid and hostid-type should not contain any characters that would be escaped in a URI path segment (as detailed below). Differing from previous protocol versions, `/` is discouraged.


### URI Path Segments

The URI specification [RFC 3986](https://www.ietf.org/rfc/rfc3986.html#section-3.3) defines a path segment as

```abns
segment = *pchar
pchar = unreserved / pct-encoded / sub-delims / ":" / "@"
unreserved  = ALPHA / DIGIT / "-" / "." / "_" / "~"
sub-delims  = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
pct-encoded = "%" HEXDIG HEXDIG
```

where HEXDIG should refer to a digit or an uppercase letter A-F. This matches the definition in https://url.spec.whatwg.org/#url-path-segment-string, which supposedly supersedes the RFC.

Thus, define `EscapePathSegment` as a function that escapes all characters that are not unreserved, sub delimiters, `:` or `@`. See the Appendix for how this function can be implemented in some of the major programming languages.


### Message Encoding

Constructing a message takes three parameters: hostid, action and (optionally) hostid-type. The content to be embedded in the URL consists of 2 path segments: host-segment and action-segment.

```
host-segment = EscapePathSegment( [hostid-type) ':'] hostid )
action-segment = EscapePathSegment(action)
message = host-segment '/' action-segment
tag = glome_tag(priv, pub, message)
```

The `hostid-type` prefix is added if and only if the `hostid-type` of the message is not empty.

Note that this voids some of the existing recommendations for 'good' actions: `shell/root`, for example, would have to be escaped and thus be less readable. Instead, using URI sub-delimiters as in `shell=root` should be recommended. This format would interact nicely with a host-identity-based authorization scheme working with key-value pairs.


### Message Decoding

Take the URL prefix up to including the `/` after the handshake message. Split this string on the character `/` and keep only the first and second element, denoted `host-segment` and `action-segment`; or fail if there are less than two elements. Replace all percent-encoded octets in the `host-segment` with their raw, unencoded form. Split the result at the character `:`. If there is one element, assign that element to `hostid` and assign the literal string `hostname` to `hostid-type`; if there are two elements assign the first one to `hostid-type` and the second to `hostid`; otherwise fail. Replace all percent-encoded octets in the `action-segment` with their raw, unencoded form, and assign the result to `action`.


## Exemplary Choice of Values

*   Use 3 octets as server prefix (encodes cleanly into 4 base64 characters and is sufficiently safe not to cause problems even for keys that change frequently, see Appendix).
*   Use only action 'shell'.

With a short hostname `glome` and omitting the domain, the URL looks like http://glome/v2/lNXP/2TZm3tVBle2tHCbb6GLfMm5cpy1UcaMv7218zHKdCMw=/host1.int.example.com/shell/ and is 94 characters long. The corresponding GLOME Login v1 variant has 94 characters as well.


# Alternatives considered

## URL Format

*   Encode both public keys in one base64 segment.
    *   This has been done in GLOME Login v1, where it improved the encoding efficiency (33 octets encode cleanly as 44 base64 chars).
    *   To reduce the risk of key conflicts, we need at least 2 octets prefix (see Appendix), which in turn requires at least 48 base64 characters, which is not worse than 44 + 4.
    *   The extra `/` character separating the public keys would be avoided.
    *   Another custom split operation (as opposed to URL path segment splitting) would be necessary.
* Allow an action to span more than one path segment.
    *   This prevents us from having an unambiguous encoding: `xxx/yyy%2Fzzz` vs. `xxx/yyy/zzz`.

## Message

*   Tag the message before URL escaping.
    *   This would have the benefit of decoupling the tagging from the transport (here, URL segments).
    *   However, we need to encode the message into a byte array before tagging.
    *   This encoding must be unambiguous as well, simply concatenating the triple won't cut it.


# Appendix

## Key Rotation Collision Probability

Given a number of total key rotations `N`, a prefix of bit length `b` and a number of active keys `k`, the probability that at after any rotation there are two keys with the same prefix is

```
P(conflict) = 1 - (1 - k / 2^b)^N
```

Assuming that we want to run for 20 years until we're replaced with a post-quantum one-time code, we rotate the key every other week and we want to keep keys for 6 months (roughly amounting to 12 active keys), a conflict would occur with the following probabilities:


| **b** | **P**   |
|-------|---------|
| 8     | 100%    |
| 16    | 9%      |
| 24    | 0.04%   |
| 32    | 0.0002% |


## URL Path Escaping APIs

### Python

```python
urllib.parse.quote(segment, safe=":@!$&'()*+,;=")
```


### Golang

:'-( https://github.com/golang/go/issues/27559


### C

GLib:

```c
g_uri_escape_string(segment, ":@!$&'()*+,;=", /*allow_utf8=*/false);
```


### Java

Guava:

```java
com.google.common.net.UrlEscapers.urlPathSegmentEscaper().escape(segment)
```


### OCaml

Uri:

```ocaml
Uri.pct_encode segment
```
